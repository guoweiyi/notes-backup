### 数据结构

在解决问题的时候，我们通常不是一下子把数据处理完，更多的时候需要先把它们放在一个容器里，等到一定的时刻再把它们拿出来。使用「数据结构」是一种「空间换时间」思想的体现，

| 数据结构 | 应用场景 |
| --- | --- |
| 栈 | 符合「后进先出」的规律 | 
| 队列 | 符合「先进先出」的规律 |
| 哈希表（散列表）| 实现「快速存取」数据的功能 |
| 二分搜索树（红黑树、B 树系列）| 维护了一组数据的顺序性，得到一个数据的上下界 |
| 并查集	| 用于处理不相交集合的「动态」连接问题 |
| 优先队列 | 有「动态」添加、删除数据且需要获得最值的场景 |
| 字典树（Trie）| 用于保存和统计大量的字符串和相关的信息 |
| 线段树 | 处理数组的区间信息的汇总（求和、最值等）、单点更新、区间更新问题 |
| 树状数组 | 处理数组的前缀和、单点更新、区间更新问题 |

### 时间复杂度与空间复杂度

g(N) 关于规模 N 的表达式

O(g(N)) 表达考虑最坏情况

时间复杂度的计算（估算）只有在输入规模特别大的时候才有意义。「输入规模特别大」往往是我们初学的时候不可感知的。大 𝑂表示法是一种事前估计法，得到一个函数表达式，它表示了：随着输入规模的扩大，程序的执行消耗会扩大的程度。这个程度不是直接从表达式上直接看出来的，需要在一个动态增加的过程中去理解程序的执行消耗会扩大的程度。

![t1](https://www.gwy.fun/blog_ima/blog/1646367420-ilEeUZ-image.png)

$ y=\log_{10}{n}$ 这个函数的图形随着 𝑛的成倍增长，纵轴数值的增长较缓慢（这已经是一种很好的时间复杂度了），到了 100000这个数量级，函数值也才到 5，「二分查找」就具有这样的时间复杂度：随着输入数据规模的增加，函数的执行次数增长较缓慢


$ y=1$ 的函数图像表示了程序的运行时间与输入数据的规模无关；



$ y=\frac{1}{10000} n^{2} $  随着的成倍增长，函数值也成比例地增长，这样的时间复杂度是性能相对较差的，这样的算法常常是「朴素解法」和「暴力解法」

在 50000 以后  $ y=\frac{1}{10000}  n^{2} $  有着更高算法复杂度。



![wechat_2025-09-02_152418_890](/Users/yun/Downloads/wechat_2025-09-02_152418_890.png)


![t2](https://www.gwy.fun/blog_ima/blog/wechat_2025-08-23_154619_176.png)

另： 除刷题外 在实用中警惕复杂度陷阱 

[视频链接](https://www.bilibili.com/video/BV16u4m1c7cU/)

参考学习：力扣课程

### 其他 ：三元运算符

condition ? value_if_true : value_if_false;