### 二分查找算法的应用范围

* 在**有序数组**中进行查找一个数（二分下标）

> 如果数据存放在链表中，访问一个元素我们都得通过遍历，有遍历的功夫我们早就找到了这个元素，因此，在链表中不适合使用二分查找。

**其中「有序」这个条件可以放宽，半有序数组或者是山脉数组里都可以应用二分查找算法。**

旋转和山脉数组的值都有规律可循，元素的值不是随机出现的，在这个特点下，「减治思想」就可以应用在旋转数组和山脉数组里的一些问题上。我们可以把这两类数组统一归纳为部分有序数组

* 在整数范围内查找一个整数（二分答案）

这种二分法用于查找一个有范围的数，也被称为「二分答案」，或者「二分结果」，也就是在「答案区间」里或者是「结果区间」里逐渐缩小目标元素的范围；

### 二分查找算法的两种思路
思路 1：在循环体中查找元素
思路 2：在循环体中排除目标元素一定不存在的区间

### 二分查找的时间复杂度

> **大 O 不在乎常数差距，只在乎增长趋势**。
>
> 故 O(2⋅logn)=O(logn)

推导**$\frac{n}{2^{k}}=1$**

**$k=\log_{2}{n} $**

### 二分查找例用

#### 基础-搜索元素位置

```
while(left <= right){
    int mid = left + (right - left)/2;
    if (nums[mid] == target){
        return mid;
    }
    else if (nums[mid] > target){
        right = mid - 1;
    }
    else{
        left = mid + 1;
    }
}
```

#### 基础-搜索元素位置 递归写法

```
public static int search(int[] nums, int target) {
    return binarySearch(nums, target, 0, nums.length - 1);
}

private static int binarySearch(int[] nums, int target, int left, int right) {
    if (left > right) {
        return -1;
    }

    int mid = left + (right - left) / 2;

    if (nums[mid] == target) {
        return mid;
    } else if (nums[mid] > target) {
        return binarySearch(nums, target, left, mid - 1);
    } else {
        return binarySearch(nums, target, mid + 1, right);
    }
}
```

#### 基础-[在有序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

| 方法           | 思路                       | 时间复杂度 | 是否符合题目要求 |
| -------------- | -------------------------- | ---------- | ---------------- |
| **线性扩展法** | 找到一个目标后向左右扩展   | O(n)       | 不符合           |
| **二分两次法** | 分别用二分找左边界和右边界 | O(log n)   | 符合             |

```
public int[] searchRange(int[] nums, int target) {
    int left = find(nums, target, true);  // 左
    int right = find(nums, target, false); // 右
    return new int[]{left, right};
}
private int find(int[] nums,int target,boolean isLeft){
    int right = nums.length - 1,left = 0;
    int bound = -1;
    while(left <= right){
        int mid = left + (right - left)/2;
        if(nums[mid] == target){
            bound = mid;
            if(isLeft){
                right = mid - 1;
            }
            else{
                left = mid + 1;
            }
        }
        else if(nums[mid] > target){
            right = mid - 1;
        }
        else{
            left = mid + 1;
        }
    }
    return bound;
}
```

#### 旋转数组-无重复[寻找最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

##### 边界处理

 情况一：`nums[mid] > nums[right]`

说明 **最小值一定在右边**（mid 不可能是最小值）。
因为 `nums[mid]` 比 `nums[right]` 大，说明从 `mid+1` 到 `right` 这段区间里一定有更小的值。

所以我们可以放心地写：

```
left = mid + 1;
```

情况二：`nums[mid] < nums[right]`

说明 **最小值在左边**，而且 `mid` 本身可能就是最小值。

所以不能丢掉 `mid`，只能写：

```
right = mid;
```

保留 `mid` 继续判断。

  当 `left == right` 时，就是最小值的下标。

-> 绕路 mid左右加和 不影响复杂度 但只需要判断 **哪一边有序**，或者 **最小值在哪一边**，就能决定收缩方向

```
public int findMin(int[] nums) {
     int left = 0;
     int right = nums.length - 1;

     while(left < right){
         int mid = left + (right - left)/2;
         if(nums[mid] > nums[right]){
            left = mid + 1;
         } else{
            right = mid;
         }
     }
     return nums[right];
}
```

#### 旋转数组有重复[最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

```
while(left < right){
     int mid = left + (right - left)/2;
     if(nums[mid] > nums[right]){
        left = mid + 1;
     } else if(nums[mid] < nums[right]){
        right = mid;
     } else{
        right--;
     }
 }
 return nums[right];
```

#### 搜索旋转数组[无重复](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

##### 法一 先找最小值，将数组拆分

```
public int search(int[] nums, int target) {
    int mainIndex = searchMin(nums);

    int leftIndex = getBound(nums,target,0,mainIndex - 1);//左面
    int rightIndex = getBound(nums,target,mainIndex,nums.length - 1);//右面

    if (leftIndex != rightIndex) return Math.max(leftIndex,rightIndex);
    else return -1;

}
private int getBound(int[] nums,int target,int left,int right){
    while(left <= right){
        int mid = left + (right - left)/2;
        if(nums[mid] == target){
            return mid;
        }
        else if(nums[mid] > target){
            right = mid - 1;
        }
        else{
            left = mid + 1;
        }
    }
    return -1;
}
private int searchMin(int[] nums){
    int left = 0;
    int right = nums.length - 1;

    while(left < right){
        int mid = left + (right - left)/2;

        if (nums[mid] < nums[right]){
            right = mid;
        }
        else if (nums[mid] > nums[right]){
            left = mid + 1;
        }
    }
    return right;
}
```

##### 法二 一步二分法

**每次二分时，至少有一半区间是有序的**。

- `if nums[left] <= nums[mid] → 左边有序`
- 否则右边有序。

**判断 target 是否在有序区间里**。

- 如果在，就缩小到有序区间；
- 如果不在，就缩小到另一半。

```
while (left <= right) {
    int mid = left + (right - left) / 2;

    if (nums[mid] == target) return mid;

    // 左边有序
    if (nums[left] <= nums[mid]) {
        if (target >= nums[left] && target < nums[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    } 
    // 右边有序
    else {
        if (target > nums[mid] && target <= nums[right]) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
}
```

#### 搜索旋转数组有重复[数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)

##### 法一 两步 改造算法保证「目标一定会落在至少一个搜索区间内」

> 小云同学还期望改造刚才的无重复数组 但她考虑到时间复杂度在最坏情况下退化为 **O(n)** 故给搜索最小数的时候也加上了 right--;但很不幸无法 AC（280/282）

样例是

nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]
target = 2

她发现在有大量重复元素的情况下（如样例），`searchMin` 找到的 **旋转点位置不唯一**，从而导致分段二分出错 她终于发现是算法思路限制 无法通过修补通过这个样例

##### 法二 

```
while(left <= right){ //错点 1
    int mid = left + (right - left)/2;

    if(nums[mid] == target) return true;

    // 遇到重复元素无法判断哪边有序
    if(nums[left] == nums[mid] && nums[mid] == nums[right]){
        left++;
        right--;
    }
    // 左半边有序
    else if(nums[mid] >= nums[left]){
        if(target >= nums[left] && target < nums[mid]){
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    // 右半边有序
    else {
        if(target > nums[mid] && target <= nums[right]){
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
}
```

