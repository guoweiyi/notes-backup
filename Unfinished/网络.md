网安强基～Web方向（1）

笔记摘录与补充



## 数据交互

### (1.1.2.2.)Ajax

在开始的时候，用户提交整个表单后才能获取结果，用户体验极差。于是Ajax (Asynchronous Javascript And XML) 技术逐渐流行起来，它**使得应用在不更新整个页面的前提下也可以获得或更新数据。**这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送那些没有改变的信息。

### (1.1.2.3)RESTful

此时，REST (Representation State Transformation) 逐渐成为一种流行的Web架构风格。

REST鼓励基于URL来组织系统功能，充分利用HTTP本身的语义，而不是仅仅将HTTP作为一种远程数据传输协议。一般RESTful有以下的特征：

- 域名和主域名分开

  api.example.com

  example.com/api/

- 带有版本控制

  api.example.com/v1

  api.example.com/v2

- 使用URL定位资源

  GET /users 获取所有用户

  GET /team/:team/users 获取某团队所有用户

  POST /users 创建用户

  PATCH/PUT /users 修改某个用户数据

  DELETE /users 删除某个用户数据

- 正确使用状态码

  使用状态码提高返回数据的可读性

- 默认使用 JSON 作为数据响应格式

- 有清晰的文档

### (1.1.4.1) Serverless

Serverless 架构由两部分组成，即 Faas (Function-as-a-Service) 和 BaaS (Backend-as-a-Service) 。

FaaS是运行平台，用户上传需要执行的逻辑函数如一些定时任务、数据处理任务等到云函数平台，配置执行条件触发器、路由等等，就可以通过云平台完成函数的执行。

BaaS包含了后端服务组件，它基于 API 完成第三方服务，主要是数据库、对象存储、消息队列、日志服务等等。

### (1.1.4.2)微服务

微服务起源于2005年Peter Rodgers博士在云端运算博览会提出的微Web服务 (Micro-Web-Service)，根本思想类似于Unix的管道设计理念。2014年，由Martin Fowler与 James Lewis共同提出了微服务的概念，定义了微服务架构风格是一种通过一套小型服务来开发单个应用的方法，每个服务运行在自己的进程中，并通过轻量级的机制进行通讯 (HTTP API) 。

微服务是一种应用于组件设计和部署架构的软件架构风格。它利用模块化的方式组合出复杂的大型应用程序：

- 各个服务功能内聚，实现与接口分离。
- 各个服务高度自治、相互解耦，可以独立进行部署、版本控制和容量伸缩。
- 各个服务之间通过 API 的方式进行通信。
- 各个服务拥有独立的状态，并且只能通过服务本身来对其进行访问。

随着微服务技术的不断发展，这种思想也被应用到了前端。2018年，第一个微前端工具single-spa出现在github。而后出现了基于single-spa的框架qiankun。

### (1.1.5.1)CI/CD

持续集成 (Continuous Integration, CI) 是让开发人员将工作集成到共享分支中的过程。频繁的集成有助于解决隔离，减少每次提交的大小，以降低合并冲突的可能性。

持续交付 (Continuous Deployment, CD) 是持续集成的扩展，它将构建从集成测试套件部署到预生产环境。这使得它可以直接在类生产环境中评估每个构建，因此开发人员可以在无需增加任何工作量的情况下，验证bug修复或者测试新特性。

## (2.1.3) OSI七层模型

### 1物理层

### 2数据链路层

- 在物理链路的两端之间传输数据
- 在网络层实体间提供数据传输功能和控制
- 提供数据的流量控制
- 检测和纠正物理链路产生的差错
- 格式化的消息称为帧

### 3网络层

- 负责端到端的数据的路由或交换，为透明地传输数据建立连接
- 寻址并解决与数据在异构网络间传输相关的所有问题
- 使用上面的传输层和下面的数据链路层的功能
- 格式化的消息称为分组

### 4传输层

- 提供**无差错的数据传输**
- 接收来自会话层的数据，如果需要，**将数据分割成更小的分组，向网络层传送分组并确保分组完整和正确到达它们的目的地**
- 在系统之间提供可靠的透明的数据传输,提供端到端的错误恢复和流量控制

### 5会话层

- 提供节点之间通信过程的协调
- 负责执行会话规则（如：连接是否允许半双工或全双工通信）、同步数据流以及当故障发生时重新建立连接
- 使用上面的表示层和下面的传输层的功能

### 6表示层

- 提供数据格式、变换和编码转换
- 涉及正在传输数据的语法和语义
- 将消息以合适电子传输的格式编码
- 执行该层的数据压缩和加密
- 从应用层接收消息，转换格式，并传送到会话层，该层常合并在应用层中

### 7应用层

- 包括各种协议，它们定义了具体的面向用户的应用：如电子邮件、文件传输等

### 总结

低三层模型属于通信子网，涉及为用户间提供透明连接，操作主要以每条链路（ hop-by-hop）为基础，在节点间的各条数据链路上进行通信。由网络层来控制各条链路上的通信，但要依赖于其他节点的协调操作。

高三层属于资源子网，主要涉及保证信息以正确可理解形式传送。

传输层是高三层和低三层之间的接口，它是第一个端到端的层次，保证透明的端到端连接，满足用户的服务质量（QoS）要求，并向高三层提供合适的信息形式。

## 2.3. TCP协议

### 三次握手-见 Code_backup

三次握手（Three-Way Handshake）是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。

第一次握手客户端将标志位 SYN 置为1，随机产生一个值 seq=s ，并将该数据包发送给服务端，客户端进入 SYN_SENT 状态，等待服务端确认。

第二次握手服务端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务端将标志位 SYN 和 ACK 都置为1，ack=s+1，随机产生一个值 seq=k ，并将该数据包发送给客户端以确认连接请求，服务端进入 SYN_RCVD 状态。

第三次握手客户端收到确认后，检查ack值是否为s+1，ACK标志位是否为1，如果正确则将标志位 ACK 置为1，ack=k+1，并将该数据包发送给服务端，服务端检查ack值是否为k+1，ACK标志位是否为1，如果正确则连接建立成功，客户端和服务端进入 ESTABLISHED 状态，完成三次握手。

![i](https://www.gwy.fun/blog_ima/blog/image-20251028151802479.png)

![image-20251028152603291](https://www.gwy.fun/blog_ima/blog/image-20251028152603291.png)

![image-20251028152959238](https://www.gwy.fun/blog_ima/blog/image-20251028152959238.png)

![image-20251028153208659](https://www.gwy.fun/blog_ima/blog/image-20251028153208659.png)

## 2.10. SSL/TLS

### 交互过程

### 2.10.3.1. Client Hello

Client Hello 由客户端发送，内容包括客户端的一个Unix时间戳(GMT Unix Time)、一些随机的字节(Random Bytes)，还包括了客户端接受的算法类型(Cipher Suites)。

### 2.10.3.2. Server Hello

Server Hello 由服务端发送，内容包括服务端支持的算法类型、GMT Unix Time以及Random Bytes。

### 2.10.3.3. Certificate

由服务端或者客户端发送，发送方会会将自己的数字证书发送给接收方，由接收方进行证书验证，如果不通过的话，接收方会中断握手的过程。一般跟在Client / Server Hello报文之后。

### 2.10.3.4. Server Key Exchange

由服务端发送，将自己的公钥参数传输给了客户端，一般也和Server Hello与Certificate在一个TCP报文中。

### 2.10.3.5. Server Hello Done

服务端发送，一般也和Server Hello、Certificate和Server Key Exchange在一个TCP报文中。

### 2.10.3.6. Client Key Exchange

客户端发送，向服务端发送自己的公钥参数，与服务端协商密钥。

### 2.10.3.7. Change Cipher Spec

客户端或者服务端发送，紧跟着Key Exchange发送，代表自己生成了新的密钥，通知对方以后将更换密钥，使用新的密钥进行通信。

### 2.10.3.8. Encrypted Handshake Message

客户端或者服务端发送，紧跟着Key Exchange发送。进行测试，一方用自己的刚刚生成的密钥加密一段固定的消息发送给对方，如果密钥协商正确无误的话，对方可以正确解密。

### 2.10.3.9. New Session Ticket

服务端发送，表示发起会话，在一段时间之内(超时时间到来之前)，双方都以刚刚交换的密钥进行通信。从这以后，加密通信正式开始。

### 2.10.3.10. Application Data

使用密钥交换协议协商出来的密钥加密的应用层的数据。

### 2.10.3.11. Encrypted Alert

客户端或服务端发送，意味着加密通信因为某些原因需要中断，警告对方不要再发送敏感的数据。![image-20251028160032554](https://www.gwy.fun/blog_ima/blog/image-20251028160032554.png)

![IMG_7151](https://www.gwy.fun/blog_ima/blog/IMG_7151.jpg)





### 四次挥手

四次挥手（Four-Way Wavehand）指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。

第一次挥手客户端发送一个 FIN ，用来关闭客户端到服务端的数据传送，客户端进入 FIN_WAIT_1 状态。

第二次挥手服务端收到 FIN 后，发送一个 ACK 给客户端，确认序号为收到序号+1，服务端进入 CLOSE_WAIT 状态。

第三次挥手服务端发送一个 FIN ，用来关闭服务端到客户端的数据传送，服务端进入 LAST_ACK 状态。

第四次挥手客户端收到 FIN 后，客户端进入 TIME_WAIT 状态，接着发送一个 ACK 给服务端，确认序号为收到序号+1，服务端进入 CLOSED 状态，完成四次挥手。

##  UDP协议

- 协议开销小、效率高。
- UDP是无连接的，即发送数据之前不需要建立连接。
- UDP使用尽最大努力交付，即不保证可靠交付。
- UDP没有拥塞控制。
- UDP支持一对一、一对多、多对一和多对多交互通信。
- UDP的首部开销小，只有8个字节。

## DHCP协议

动态主机配置协议 (Dynamic Host Configuration Protocol，DHCP) 是一个用于局域网的网络协议，位于OSI模型的应用层，使用UDP协议工作，主要用于自动分配IP地址给用户，方便管理员进行统一管理。

DHCP服务器端使用67/udp，客户端使用68/udp。DHCP运行分为四个基本过程，分别为请求IP租约、提供IP租约、选择IP租约和确认IP租约。客户端在获得了一个IP地址以后，就可以发送一个ARP请求来避免由于DHCP服务器地址池重叠而引发的IP冲突。

## DNS解析过程

DNS解析过程是递归查询的，具体过程如下：

- 用户要访问域名www.example.com时，先查看本机hosts是否有记录或者本机是否有DNS缓存，如果有，直接返回结果，否则向递归服务器查询该域名的IP地址
- 递归缓存为空时，首先向根服务器查询com顶级域的IP地址
- 根服务器告知递归服务器com顶级域名服务器的IP地址
- 递归向com顶级域名服务器查询负责example.com的权威服务器的IP
- com顶级域名服务器返回相应的IP地址
- 递归向example.com的权威服务器查询www.example.com的地址记录
- 权威服务器告知www.example.com的地址记录
- 递归服务器将查询结果返回客户端

## 服务器类型

### 根服务器

根服务器是DNS的核心，负责互联网顶级域名的解析，用于维护域的权威信息，并将DNS查询引导到相应的域名服务器。

根服务器在域名树中代表最顶级的 `.` 域， 一般省略。

13台IPv4根服务器的域名标号为a到m，即a.root-servers.org到m.root-servers.org，所有服务器存储的数据相同，仅包含ICANN批准的TLD域名权威信息。

### 权威服务器

权威服务器上存储域名Zone文件，维护域内域名的权威信息，递归服务器可以从权威服务器获得DNS查询的资源记录。

权威服务器需要在所承载的域名所属的TLD管理局注册，同一个权威服务器可以承载不同TLD域名，同一个域也可以有多个权威服务器。

### 递归服务器

递归服务器负责接收用户的查询请求，进行递归查询并响应用户查询请求。在初始时递归服务器仅有记录了根域名的Hint文件。

## Cookie

### name

### value

### expires

当 Expires 属性缺省时，表示是会话性 Cookie，在用户关闭浏览器时失效。

### max-age

max-age 可以为正数、负数、0。如果 max-age 属性为正数时，浏览器会将其持久化，当 max-age 属性为负数，则表示该 Cookie 只是一个会话性 Cookie。当 max-age 为 0 时，则会立即删除这个 Cookie。Expires 和 max-age 都存在的条件下，max-age 优先级更高。

### domain

指定Cookie的域名，默认是当前域名。domain设置时可以设置为自身及其父域，子域可以访问父域的Cookie，反之不能。

### path

指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送对应的 Cookie。

### secure

只能通过 HTTPS 传输。

### httponly

限制Cookie仅在HTTP传输过程中被读取，一定程度上防御XSS攻击。

### SameSite

SameSite 支持 Strict / Lax / None 三种值。Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。Lax 允许部分第三方请求携带 Cookie，主要是链接、预加载、GET 表单三种情况。Cookie 的 SameSite 属性为 None ，且设置了 Secure 时，无论是否跨站都会发送 Cookie。



