## 快速排序

1. **选一个基准值**
   - 从数组中随机取一个元素，比如 `x = q[l + rand() % (r - l + 1)]`。
   - 随机化是为了避免最坏情况（比如数组已经有序时）。
2. **划分区间**
   - 用两个指针 `i` 和 `j`，分别从区间两端往中间走：
     - `i` 找到 **大于等于基准值** 的元素。
     - `j` 找到 **小于等于基准值** 的元素。
     - 然后交换 `q[i]` 和 `q[j]`，直到 `i >= j` 为止。
3. **递归处理左右区间**
   - 此时 `q[l..j]` 中的数都 ≤ 基准值，`q[j+1..r]` 中的数都 ≥ 基准值。
   - 对两个子区间再递归调用快速排序。

------

#### 代码

------

```
    int i = l - 1, j = r + 1;
    int x = q[l + rand() % (r - l + 1)]; // 随机基准值
```

- `i` 从左边界外开始，`j` 从右边界外开始。
- 这样方便用 `do...while`，让指针至少移动一次。

------

```
    while(i < j){
        do i++; while(q[i] < x);   // 找到第一个 >= x 的元素
        do j--; while(q[j] > x);   // 找到第一个 <= x 的元素
        if(i < j) swap(q[i],q[j]); // 交换错位的元素
    }
```

- 循环保证了：
  - 左边部分始终 ≤ x
  - 右边部分始终 ≥ x
- 当 `i >= j` 时，说明左右已经划分好了。

------

```
    quick_sort(q,l,j);       // 递归排左半部分
    quick_sort(q,j + 1,r);   // 递归排右半部分
```

------

#### 举例

数组：

```
q = [5, 2, 7, 3, 1]
```

1. 随机选基准 `x = 3`
2. 指针移动：
   - 左边找到 `5 >= 3`
   - 右边找到 `1 <= 3`
   - 交换 → `[1, 2, 7, 3, 5]`
   - 再移动：左指针停在 `7`，右指针停在 `3` → 交换 → `[1, 2, 3, 7, 5]`
   - 此时 `i >= j`，划分结束。
3. 得到两边：
   - 左 `[1, 2]`
   - 右 `[7, 5]`
   - 分别递归排序。

## **归并排序** 

### 思路

1. **分解 **
    不断把区间 `[l, r]` 一分为二，直到每个小区间只有一个元素（自然有序）。
2. **合并**
    把两个已经排好序的子区间合并成一个有序区间。
3. **合并时借助辅助数组 tmp**
    先把有序结果存进临时数组，最后再拷贝回原数组。

时间复杂度是 **O(n log n)**，空间复杂度是 **O(n)**（需要一个辅助数组）。

### 代码

```cpp
void merge_sort(int q[],int l,int r){
    if(l >= r) return;
    
    int mid = l + r >> 1;
    
    merge_sort(q,l,mid);
    merge_sort(q,mid + 1,r);
    
    int k = 0,i = l,j = mid + 1;
    
    while(i <= mid && j <= r){
        if( q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    while(i <= mid) tmp[k++] = q[i++];
    while(j <= r) tmp[k++] = q[j++];
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

------

```cpp
    int mid = l + r >> 1; 
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
```

- 找中点 `mid`，递归排序 `[l, mid]` 和 `[mid+1, r]`。

------

```cpp
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
```

- `i` 指针从左区间开头走，`j` 指针从右区间开头走。
- 每次比较 `q[i]` 和 `q[j]`，谁小就先放进 `tmp`。
- 这样保证 `tmp` 始终是有序的。

------

```cpp
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
```

- 如果一边区间先走完，另一边剩下的直接接到 `tmp` 末尾。

------

```cpp
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
```

- 把排好序的 `tmp` 数组复制回 `q[l..r]`，完成区间的归并。

------

### 举例

假设数组：

```
q = [5, 2, 7, 3]
```

1. 分解：
   - [5, 2, 7, 3]
   - → [5, 2] 和 [7, 3]
   - → [5] [2] [7] [3]
2. 合并：
   - [5] 和 [2] → [2, 5]
   - [7] 和 [3] → [3, 7]
   - [2, 5] 和 [3, 7] → [2, 3, 5, 7]

最终结果：`[2, 3, 5, 7]`

### 拓展

归并时，左右两个子数组本身都是有序的

故可在归并时计算逆序对的数量

```cpp
while (i <= mid && j <= r) {
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        else {
            tmp[k++] = q[j++];
            res += (mid - i + 1);   
            // q[i] > q[j] 时，左区间 [i..mid] 的数都比 q[j] 大
        }
    }
```

------

####  小例

```
左: [3, 8, 9]
右: [5, 6]
```

当比较到：

- `i=0` → q[i]=3
- `j=0` → q[j]=5

→ 3 ≤ 5，不构成逆序对。

然后：

- `i=1` → q[i]=8
- `j=0` → q[j]=5

→ 8 > 5，构成逆序对。
 左边从 `i=1` 开始到 `mid=2` → `[8, 9]` 全部比 5 大。
 所以一次性加上 **2 个逆序对**。

## 总结

- **快排**：分区，基准数，左右交换。平均 O(n log n)，最坏 O(n²)。
- **归并排序**：分治 + 合并。时间复杂度稳定 O(n log n)，但要额外 O(n) 空间。

每次合并需要 O(n) 总共 log n 层递归 所以是 O(n log n)
 先分解（递归到最小单元），再合并（两个有序数组 → 一个更大的有序数组）。

